import json, re, sys, pathlib

USAGE = "usage: python normalize_pred_with_choices.py <pred_norm.jsonl> <dataset.strict|prompted.jsonl> <out.jsonl>"

def read_jsonl(path):
    with open(path, encoding="utf-8") as f:
        for line in f:
            line=line.strip()
            if not line: continue
            try: yield json.loads(line)
            except: pass

MCQ_INLINE = re.compile(r'(?is)\b([A-D])\s*[\.\)\]:\-]\s*(.+?)(?=(?:\b[A-D]\s*[\.\)\]:\-]\s*)|$)')

def choices_from_item(item):
    arr = item.get("choices") or item.get("options")
    if isinstance(arr, list) and len(arr) >= 2:
        abc = "ABCD"
        return {abc[i]: str(arr[i]).strip() for i in range(min(4, len(arr)))}
    for key in ("input","question","prompt","context"):
        txt = item.get(key)
        if not isinstance(txt, str): 
            continue
        out = {}
        for m in MCQ_INLINE.finditer(txt):
            L = m.group(1).upper()
            body = m.group(2).strip()
            if L in "ABCD" and L not in out:
                out[L] = body
        if out:
            return out
    return {}

def norm_text(s: str):
    return re.sub(r'[\W_]+', '', (s or '').lower())

def extract_token_from_pred(o):
    fields = [o.get("label"), o.get("answer"), o.get("pred"), o.get("output"), o.get("text"), o.get("response")]
    # 1) Answer: X
    for f in fields:
        if isinstance(f, str):
            m = re.search(r'(?i)\b(?:final\s+answer|answer)\s*[:：]\s*([A-D]|YES|NO|TRUE|FALSE|-?\d+)\b', f)
            if m:
                tok = m.group(1).upper()
                if tok == "TRUE": tok = "YES"
                if tok == "FALSE": tok = "NO"
                return tok
    # 2) option/choice X
    for f in fields:
        if isinstance(f, str):
            m = re.search(r'(?i)\b(?:option|choice)\s*([A-D1-4])\b', f)
            if m:
                return m.group(1).upper()
    # 3) 最終行の単独トークン
    for f in fields:
        if isinstance(f, str):
            last = f.strip().splitlines()[-1].strip()
            for pat in (r'^([A-D])\.?$', r'\b(YES|NO|TRUE|FALSE)\b', r'(-?\d+)\b'):
                m = re.search(pat, last, re.I)
                if m:
                    tok = m.group(1).upper()
                    if tok == "TRUE": tok = "YES"
                    if tok == "FALSE": tok = "NO"
                    return tok
    return None

def num_to_letter(tok):
    m = re.fullmatch(r'[1-4]', str(tok or '').strip())
    if not m: return None
    return "ABCD"[int(tok)-1]

def fallback_match_by_text(fields, rev):
    """tok が無い場合の救済：fields 文字列が choices 本文と一致/含有したら A–D を返す"""
    # 完全一致（正規化後）
    for f in fields:
        if not isinstance(f, str): continue
        nf = norm_text(f)
        if nf in rev: 
            return rev[nf]
    # 含有（正規化後）
    for f in fields:
        if not isinstance(f, str): continue
        nf = norm_text(f)
        for body_norm, letter in rev.items():
            if body_norm and body_norm in nf:
                return letter
    return None

def main():
    if len(sys.argv) != 4:
        print(USAGE, file=sys.stderr); sys.exit(2)
    pred_path, dataset_path, out_path = sys.argv[1:4]

    id2choices = {}
    for item in read_jsonl(dataset_path):
        i = item.get("id")
        if i is None: continue
        ch = choices_from_item(item)
        if ch: id2choices[str(i)] = ch

    total_in = total_ok = 0
    out_p = pathlib.Path(out_path)
    out_p.parent.mkdir(parents=True, exist_ok=True)

    with open(out_path, "w", encoding="utf-8") as fo:
        for o in read_jsonl(pred_path):
            total_in += 1
            i = o.get("id")
            if i is None: 
                continue

            ch = id2choices.get(str(i), {})
            rev = {norm_text(v): k for k, v in ch.items()}  # choice body → A-D
            fields = [o.get("label"), o.get("answer"), o.get("pred"), o.get("output"), o.get("text"), o.get("response")]

            tok = extract_token_from_pred(o)

            # ① 1-4 → A-D
            if tok and re.fullmatch(r'[1-4]', tok):
                tok = num_to_letter(tok)

            # ② tok があるが A-D/YES/NO 以外 → テキスト一致で A-D に
            if tok and tok not in ("A","B","C","D","YES","NO"):
                key = norm_text(tok)
                if key in rev:
                    tok = rev[key]

            # ③ tok が無い → fields の本文を choices と照合（完全一致→含有）
            if (not tok) and ch:
                tok = fallback_match_by_text(fields, rev)

            out = dict(o)
            if ch:
                out["label"] = tok if tok in ("A","B","C","D","YES","NO") else None
            else:
                out["label"] = tok

            json.dump(out, fo, ensure_ascii=False); fo.write("\n")
            if out.get("label") is not None:
                total_ok += 1

    print(f"[OK] choices-aware normalized {total_ok}/{total_in} -> {out_path} spec={{'type':'letters','letters':['A','B','C','D']}}")

if __name__ == "__main__":
    main()
