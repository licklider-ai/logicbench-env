#!/usr/bin/env python3
import json, sys, pathlib, re

INP  = pathlib.Path(sys.argv[1])   # pred_<ts>_<model>.norm.jsonl（id, output/pred_raw 等）
DATA = pathlib.Path(sys.argv[2])   # dataset（choices/options を持つ）
OUT  = pathlib.Path(sys.argv[3])   # 出力：*.choicesaware.jsonl

LETTER = ['A','B','C','D']

def norm_token(s:str)->str:
    if s is None: return ""
    u = str(s).strip()
    U = u.upper()
    m = re.search(r'ANSWER:\s*([A-Z]|YES|NO|TRUE|FALSE|[-+]?\d+)\b', U)
    if m: U = m.group(1)
    if U == "TRUE":  U = "YES"
    if U == "FALSE": U = "NO"
    # 先頭トークンのみ。末尾句読点は落とす
    return U.split()[0].strip(",.;:") if U else ""

def to_letter(idx:int):
    return LETTER[idx] if 0 <= idx < len(LETTER) else None

# dataset を id -> {choices/options} に
ds = {}
with DATA.open(encoding="utf-8") as f:
    for line in f:
        line=line.strip()
        if not line: continue
        o=json.loads(line)
        rid=str(o.get("id"))
        if not rid: continue
        ch = o.get("choices") or o.get("options")
        ds[rid] = {
            "choices": ch if isinstance(ch, list) else None
        }

def infer_label_from_output(rid, out_tok):
    """out_tok（正規化済み）から A/B/C/D を推定。"""
    meta = ds.get(rid) or {}
    choices = meta.get("choices")
    if not out_tok:
        return None

    # 1) すでに A-D/YES/NO ならそのまま（YES/NO は choices からレター化も試みる）
    if out_tok in LETTER:
        return out_tok

    # 2) YES/NO が choices に含まれていれば対応位置でレター化
    if choices:
        norm_choices = [norm_token(c) for c in choices]
        # 完全一致（"7" = "7", "YES"="YES" など）
        for i, nc in enumerate(norm_choices):
            if nc == out_tok:
                return to_letter(i)

    # 3) out_tok が数字なら、choices が数字配列のとき一致でレター化
    if re.fullmatch(r'[-+]?\d+', out_tok) and choices:
        norm_choices = [norm_token(c) for c in choices]
        for i, nc in enumerate(norm_choices):
            if nc == out_tok:
                return to_letter(i)

    # 4) どうしても無理なら None（上位で raw を pred_raw として残す）
    return None

cnt=0; done=0
with INP.open(encoding="utf-8") as fin, OUT.open("w", encoding="utf-8") as fout:
    for line in fin:
        line=line.strip()
        if not line: continue
        cnt+=1
        row = json.loads(line)
        rid = str(row.get("id"))
        out_obj = dict(row)  # 既存キーは温存（usage/category など）

        # 既に label があれば pred も合わせて入れて終了
        lbl = row.get("label")
        if lbl:
            out_obj["label"] = str(lbl).upper()
            out_obj["pred"]  = out_obj["label"]
            fout.write(json.dumps(out_obj, ensure_ascii=False) + "\n")
            done += 1
            continue

        # 出力候補の拾い上げ
        out_tok = norm_token(row.get("pred") or row.get("label") or row.get("answer") or row.get("output") or row.get("pred_raw"))
        # レター推定
        letter = infer_label_from_output(rid, out_tok)

        if letter:
            out_obj["label"] = letter
            out_obj["pred"]  = letter
            done += 1
        else:
            # レター化できなくても pred に raw を入れておく（スコアラーは pred_raw/answer も見るが pred 優先）
            if out_tok:
                out_obj["pred"] = out_tok

        fout.write(json.dumps(out_obj, ensure_ascii=False) + "\n")

print(f"[OK] choices-aware normalized {done}/{cnt} -> {OUT}")
