import json, re, sys, pathlib

USAGE = "usage: python normalize_pred_with_choices.py <pred_norm.jsonl> <dataset.strict|prompted.jsonl> <out.jsonl>"

def read_jsonl(path):
    with open(path, encoding="utf-8") as f:
        for line in f:
            line=line.strip()
            if not line: continue
            try: yield json.loads(line)
            except: pass

# A-D を本文から抜く（縦/横並びどちらも拾う）
MCQ_INLINE = re.compile(r'(?is)\b([A-D])\s*[\.\)\]:\-]\s*(.+?)(?=(?:\b[A-D]\s*[\.\)\]:\-]\s*)|$)')

def choices_from_item(item):
    """item から choices を {A: text, ...} で返す。配列/テキストどちらでもOK"""
    # 1) choices / options が配列なら最優先
    arr = item.get("choices") or item.get("options")
    if isinstance(arr, list) and len(arr) >= 2:
        abc = "ABCD"
        return {abc[i]: str(arr[i]).strip() for i in range(min(4, len(arr)))}
    # 2) 入力テキストから抽出（input/question/prompt/context を順に）
    for key in ("input","question","prompt","context"):
        txt = item.get(key)
        if not isinstance(txt, str): 
            continue
        out = {}
        for m in MCQ_INLINE.finditer(txt):
            L = m.group(1).upper()
            body = m.group(2).strip()
            if L in "ABCD" and L not in out:
                out[L] = body
        if out:
            return out
    return {}

def norm_text(s: str):
    return re.sub(r'[\W_]+', '', (s or '').lower())

def extract_token_from_pred(o):
    """pred 1件からラベル候補を抽出（Answer: X / option/choice X / 最終行）"""
    fields = [o.get("label"), o.get("answer"), o.get("pred"), o.get("output"), o.get("text"), o.get("response")]

    # 1) 明示 "Answer: X"
    for f in fields:
        if isinstance(f, str):
            m = re.search(r'(?i)\b(?:final\s+answer|answer)\s*[:：]\s*([A-D]|YES|NO|TRUE|FALSE|-?\d+)\b', f)
            if m:
                tok = m.group(1).upper()
                if tok == "TRUE": tok = "YES"
                if tok == "FALSE": tok = "NO"
                return tok

    # 2) "option/choice X"
    for f in fields:
        if isinstance(f, str):
            m = re.search(r'(?i)\b(?:option|choice)\s*([A-D1-4])\b', f)
            if m:
                return m.group(1).upper()

    # 3) 最終行：単独の A–D / YES/NO / 数値
    for f in fields:
        if isinstance(f, str):
            last = f.strip().splitlines()[-1].strip()
            for pat in (r'^([A-D])\.?$', r'\b(YES|NO|TRUE|FALSE)\b', r'(-?\d+)\b'):
                m = re.search(pat, last, re.I)
                if m:
                    tok = m.group(1).upper()
                    if tok == "TRUE": tok = "YES"
                    if tok == "FALSE": tok = "NO"
                    return tok
    return None

def num_to_letter(tok):
    m = re.fullmatch(r'[1-4]', str(tok or '').strip())
    if not m: return None
    return "ABCD"[int(tok)-1]

def main():
    if len(sys.argv) != 4:
        print(USAGE, file=sys.stderr); sys.exit(2)
    pred_path, dataset_path, out_path = sys.argv[1:4]

    # dataset から id→choices(A-D) を構築
    id2choices = {}
    for item in read_jsonl(dataset_path):
        i = item.get("id")
        if i is None: continue
        ch = choices_from_item(item)
        if ch: id2choices[str(i)] = ch

    total_in = total_ok = 0
    out_p = pathlib.Path(out_path)
    out_p.parent.mkdir(parents=True, exist_ok=True)

    with open(out_path, "w", encoding="utf-8") as fo:
        for o in read_jsonl(pred_path):
            total_in += 1
            i = o.get("id")
            if i is None: 
                continue

            ch = id2choices.get(str(i), {})
            rev = {norm_text(v): k for k, v in ch.items()}  # テキスト→A-D

            tok = extract_token_from_pred(o)

            # ① 1-4 → A-D
            if tok and re.fullmatch(r'[1-4]', tok):
                tok = num_to_letter(tok)

            # ② テキスト一致で A-D に（例: "Earth"）
            if tok and tok not in ("A","B","C","D","YES","NO"):
                key = norm_text(tok)
                if key in rev:
                    tok = rev[key]

            # ③ 念のため再度 1-4 → A-D
            if tok and re.fullmatch(r'[1-4]', str(tok)):
                tok = num_to_letter(tok)

            out = dict(o)
            if ch:
                # MCQ は A-D/YES/NO 以外は未確定(None)
                out["label"] = tok if tok in ("A","B","C","D","YES","NO") else None
            else:
                # 非MCQはそのまま（数値や YES/NO も許容）
                out["label"] = tok

            json.dump(out, fo, ensure_ascii=False); fo.write("\n")
            if out.get("label") is not None:
                total_ok += 1

    print(f"[OK] choices-aware normalized {total_ok}/{total_in} -> {out_path} spec={{'type':'letters','letters':['A','B','C','D']}}")

if __name__ == "__main__":
    main()
