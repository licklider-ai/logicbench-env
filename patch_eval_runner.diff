*** a/scripts/eval_runner.py
--- b/scripts/eval_runner.py
@@
-import os, json, time, re
-from pathlib import Path
-from typing import Dict, Any, List
+import os, json, time, re, sys, random
+from pathlib import Path
+from typing import Dict, Any, List, Tuple, Optional
+from openai import OpenAI
 
 MODEL   = os.getenv("LB_MODEL", "gpt-4o-mini")
 IN_PATH = os.getenv("LB_DEV_PATH", "data/dev_20.jsonl")
 OUT_PATH= os.getenv("LB_OUT_PATH", "runs/pred_raw.jsonl")
 
+LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+
+# ===================== OpenAI client =====================
+_api = os.getenv("OPENAI_API_KEY")
+if not _api:
+    print("ERROR: OPENAI_API_KEY is not set.", file=sys.stderr)
+    sys.exit(2)
+client = OpenAI(api_key=_api)
+
+# ===================== prompt builders =====================
+def build_prompt(stem: str, choices: List[str]) -> Tuple[str, str, str]:
+    """
+    return (system, user, valid_letters)
+    - 選択肢が YES/NO 系なら [YES,NO] を許容
+    - それ以外は A.. の1文字のみ
+    """
+    chu = [str(c).strip().upper() for c in choices]
+    is_yn = False
+    if len(chu) == 2 and set(chu) <= {"YES","NO","TRUE","FALSE"}:
+        is_yn = True
+    if set(chu) <= {"YES","NO"}:
+        is_yn = True
+
+    if is_yn:
+        system = (
+            "Answer with EXACTLY ONE token from this set: YES,NO. "
+            "No words, no punctuation, no spaces, no quotes."
+        )
+        user = f"{stem}\n\nReturn only one token: YES or NO."
+        valid = "YESNO"
+        return system, user, valid
+
+    valid = LETTERS[:len(choices)]
+    system = (
+        f"Answer with EXACTLY ONE uppercase letter from this set: {','.join(list(valid))}. "
+        "No words, no punctuation, no spaces, no quotes."
+    )
+    user = (
+        f"{stem}\n\nChoices:\n"
+        + "\n".join([f"{LETTERS[i]}. {c}" for i, c in enumerate(choices)])
+        + f"\n\nReturn only one letter from [{valid}] and nothing else."
+    )
+    return system, user, valid
+
+# ===================== extractors =====================
+_ANS_RE = re.compile(r'\bANSWER:\s*([A-Z]|YES|NO|TRUE|FALSE|T|F|-?\d+)\b', re.I)
+def _norm_short_token(s: str) -> str:
+    s = s.strip().upper()
+    s = s.replace("TRUE","YES").replace("FALSE","NO")
+    if s == "T": s = "YES"
+    if s == "F": s = "NO"
+    return s
+
+def extract_one_token(raw: str, k: int, mode_letters: bool) -> Optional[str]:
+    if not raw:
+        return None
+    txt = raw.strip()
+    m = _ANS_RE.search(txt)
+    if m:
+        cand = _norm_short_token(m.group(1))
+    else:
+        cand = _norm_short_token(txt)
+        if mode_letters and not re.fullmatch(r'[A-Z]', cand):
+            m2 = re.fullmatch(r'([A-Z])[\.\s]*', txt.strip(), re.I)
+            if m2:
+                cand = m2.group(1).upper()
+    if mode_letters:
+        if re.fullmatch(r'[A-Z]', cand) and (ord(cand) - 65) < k:
+            return cand
+        return None
+    else:
+        return cand if cand in {"YES","NO"} else None
+
+# ===================== API calls with retry =====================
+def call_chat(system: str, user: str, budget: int) -> str:
+    return client.chat.completions.create(
+        model=MODEL,
+        messages=[{"role":"system","content":system},{"role":"user","content":user}],
+        max_completion_tokens=budget,
+        temperature=0,
+    ).choices[0].message.content or ""
+
+def call_with_retries(system: str, user: str, k: int, mode_letters: bool) -> Tuple[Optional[str], str]:
+    budgets = (64, 128, 256)
+    last_raw = ""
+    for b in budgets:
+        try:
+            raw = call_chat(system, user, budget=b)
+            last_raw = raw
+            tok = extract_one_token(raw, k, mode_letters)
+            if tok is not None:
+                return tok, raw
+        except Exception as e:
+            time.sleep(0.8 + random.random())
+            last_raw = f"[chat.error: {e}]"
+            continue
+    return None, last_raw
+
+# ===================== main loop =====================
@@
-    print(f"[done] wrote {OUT_PATH} ({done} lines)")
+    print(f"[done] raw -> {OUT_PATH}")
+    print(f"[done] normalized -> runs/pred_normalized.jsonl")
